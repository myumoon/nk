//=============================================================================
/*	file	vector.cpp
	brief	vector
	author	ryunosuke ide
	
	Copyright (c) 2014 Ryunosuke Ide
	Released under the MIT license
	http://opensource.org/licenses/mit-license.php
*/
//=============================================================================

#include <nk/math/vector.h>

#include <math.h>
#include <float.h>

#include <nk/math/vecutil.inl>
#include <nk/math/matrix.h>


namespace {
}


namespace nk {
namespace math {



//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec2::Vec2()
{
	x	= 0.0f;
	y	= 0.0f;
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec2::Vec2( f32 x, f32 y )
{
	this->x	= x;
	this->y	= y;
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec2::Vec2( f32* ary2 )
{
	x	= ary2[0];
	y	= ary2[1];
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec2::Vec2( const Vec2& vec2 )
{
	VecCopy( *this, vec2 );
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec2::Vec2( const Vec3& vec3 )
{
	VecCopy( *this, vec3 );
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec2::Vec2( const Vec4& vec4 )
{
	VecCopy( *this, vec4 );
}














//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec3::Vec3()
{
	x	= 0.0f;
	y	= 0.0f;
	z	= 0.0f;
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec3::Vec3( f32 x, f32 y, f32 z )
{
	this->x	= x;
	this->y	= y;
	this->z	= z;
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec3::Vec3( f32* ary3 )
{
	x	= ary3[0];
	y	= ary3[1];
	z	= ary3[2];
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec3::Vec3( const Vec2& vec2 )
{
	VecCopy( *this, vec2 );
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec3::Vec3( const Vec3& vec3 )
{
	VecCopy( *this, vec3 );
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec3::Vec3( const Vec4& vec4 )
{
	VecCopy( *this, vec4 );
}


//===========================================================================
/*	brief		行列演算
	param		rhs		行列
	return		計算結果のベクトル
*/
//===========================================================================
Vec3 Vec3::operator*( const Matrix44& rhs ) const
{
	Vec3	ans;

	ans.x	=	rhs.ary44[0][0] * x + rhs.ary44[1][0] * y + rhs.ary44[2][0] * z + rhs.ary44[3][0];
	ans.y	=	rhs.ary44[0][1] * x + rhs.ary44[1][1] * y + rhs.ary44[2][1] * z + rhs.ary44[3][1];
	ans.z	=	rhs.ary44[0][2] * x + rhs.ary44[1][2] * y + rhs.ary44[2][2] * z + rhs.ary44[3][2];

	return ans;
}


//===========================================================================
/*	brief	ベクトルの外積を計算
	param	vec1,vec2:ベクトル
	return	２ベクトルに垂直でノルムが|vec1||vec2|sinθのベクトル
	note	ノルムは計算しない
*/
//===========================================================================
Vec3 CrossProduct( const Vec3& vec1, const Vec3& vec2 )
{
	NKASSERT( !vec1.IsZero(), "vec1 is zero vector" );
	NKASSERT( !vec2.IsZero(), "vec2 is zero vector" );
	
	Vec3	vec1_cpy( vec1 );
	Vec3	vec2_cpy( vec2 );
	
	
	// 外積の計算
	// (y1*z2-z1y2, z1*x2-x1*z2, x1*y2-y1*x2)
	// ノルムは |v1||v2|sinθ
	// 向きは座標系により異なる
	Vec3	cross;
	cross.x	= vec1_cpy.y * vec2_cpy.z - vec1_cpy.z * vec2_cpy.y;
	cross.y	= vec1_cpy.z * vec2_cpy.x - vec1_cpy.x * vec2_cpy.z;
	cross.z	= vec1_cpy.x * vec2_cpy.y - vec1_cpy.y * vec2_cpy.x;

	return cross;
}


//===========================================================================
/*	brief	ベクトルのなす角を計算
	param	vec1,vec2:計算するベクトル
	return	なす角
*/
//===========================================================================
f32 CalcAngle( const Vec3& begin, const Vec2& end )
{
	NKASSERT( !begin.IsZero(),	"vec1 is zero vector" );
	NKASSERT( !end.IsZero(),		"vec2 is zero vector" );
	
	const Vec3 n_begin		= begin.GetNormalized();
	const Vec3 n_end		= end.GetNormalized();

	// cosθ = a・b / |a||b|
	//-----------------------------------------------
	const f32	angle = DotProduct( n_begin, n_end ) / 1.0f;

	return acos(angle);
}







//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec4::Vec4()
{
	x	= 0.0f;
	y	= 0.0f;
	z	= 0.0f;
	w	= 0.0f;
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec4::Vec4( f32 x, f32 y, f32 z, f32 w )
{
	this->x	= x;
	this->y	= y;
	this->z	= z;
	this->w	= w;
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec4::Vec4( f32* ary4 )
{
	x	= ary4[0];
	y	= ary4[1];
	z	= ary4[2];
	w	= ary4[3];
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec4::Vec4( const Vec2& vec2 )
{
	VecCopy( *this, vec2 );
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec4::Vec4( const Vec3& vec3 )
{
	VecCopy( *this, vec3 );
}


//===========================================================================
/*	brief	コンストラクタ
*/
//===========================================================================
Vec4::Vec4( const Vec4& vec4 )
{
	VecCopy( *this, vec4 );
}


//===========================================================================
/*	brief		行列演算
	param		rhs		行列
	return		計算結果のベクトル
*/
//===========================================================================
Vec4 Vec4::operator*( const Matrix44& rhs ) const
{
	f32 ans[4] = { 0 };

	ans[0]	=	rhs.ary44[0][0] * x + rhs.ary44[1][0] * y + rhs.ary44[2][0] * z + rhs.ary44[3][0] * w;
	ans[1]	=	rhs.ary44[0][1] * x + rhs.ary44[1][1] * y + rhs.ary44[2][1] * z + rhs.ary44[3][1] * w;
	ans[2]	=	rhs.ary44[0][2] * x + rhs.ary44[1][2] * y + rhs.ary44[2][2] * z + rhs.ary44[3][2] * w;
	ans[3]	=	rhs.ary44[0][3] * x + rhs.ary44[1][3] * y + rhs.ary44[2][3] * z + rhs.ary44[3][3] * w;

	return Vec4(ans[0], ans[1], ans[2], ans[3]);
}


}	// namespace math
}	// namespace nk

